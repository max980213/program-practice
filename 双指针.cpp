//双指针编程思想
//例子：给定递增序列，求序列中的两个不同位置数a和b，使其加和等于M，输出所有满足条件的方案
//最简单的思想就是双循环，依次枚举，但当序列很大时复杂度O(n^2)是无法承受的
//思考：若对于一个确定的a[i]+a[j]>M，则a[i+1]+a[j]和a[i]+a[j+1]均大于M（序列递增）
//由此和消掉很多没有必要的枚举
//由此引入双指针，一个指向第一个元素，一个指向最后一个元素，由a[i]+a[j]与M的关系决定指针如何移动

#include <stdio.h>

void twopointers(int a[],int n,int M)
{
    int i=0,j=n-1;
    while(i<j)
    {
        if(a[i]+a[j]==M)  //相等需同时移动指针，只移动一个会导致结果大于M
        {
            printf("%d %d",a[i],a[j]);
            i++;
            j--;
        }
        else if(a[i]+a[j]<M)   //小于M，头指针右移（序列递增）
        {
            i++;
        }
        else
            j--;
    }
}

//同样的思想也可以用在序列合并问题：设两个有序序列A、B，将它们合并为有序序列C
//同样的可以设置i、j分别指向两个序列的头元素，比较大小决定将哪个元素放在C中

void merge(int A[],int B[],int C[],int n,int m)
{
    int i=0,j=0,index=0;
    while(i<n&&j<m)
    {
        if(A[i]<=B[j])
        {
            C[index++]=A[i++];
        }
        else
            C[index++]=B[j++];
    }
    while(i<n)
        C[index++]=A[i++];
    while(j<m)
        C[index++]=B[j++];  //将A和B的剩余元素补上
}


//双指针思想，即利用两个下标对数组进行扫描，达到降低复杂度（一般为O(n)）的目的，不一定一定要求一个头一个尾
//快速排序用到了双指针

int main()
{
    //
}
